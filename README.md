# Асинхронные вычисления

Итак, мы хотим реализовать конкретную схему:

- в одном потоке сдать пальто в чистку;
- в другом потоке пойти гулять с собакой, не дожидаясь окончания чистки.

Так выглядит синхронный вариант:
```c++
const CleaningReport report = CleanCoat(coat, money);
const bool is_dog_happy = WalkDog(dog);
```

А так — асинхронный:
```c++
#include <future>

// ... 

future<CleaningReport> coat_future =
    async([&coat, money] { return CleanCoat(coat, money); });
const bool is_dog_happy = WalkDog(dog);  // любые действия, не связанные с пальто
const auto report = coat_future.get();
```

Обо всём по порядку:

1. В библиотеке `<future>` объявлены функция `async` и шаблон `future`.
2. `async` принимает функцию, которую нужно запустить асинхронно. По возможности она запускается немедленно, а возвращается из `async` тот самый «талончик» — объект `future<FunctionResult>`. Позже он позволит получить результат выполнения асихнронной функции типа `FunctionResult`.
3. Гуляем с собакой. Если потоков достаточно, пальто уже чистится.
4. Вызов метода `get` для `future<FunctionResult>` переводит текущий поток в режим ожидания окончания выполнения асинхронной функции. Как только она завершилась, из `get` возвращается результат.

Функция `async` умеет принимать не только функцию без параметров: после функции можно указать аргументы, с которыми она должна быть запущена. Но если указать их как есть, они скопируются:
```c++
future<CleaningReport> coat_future = async(CleanCoat, coat, money);
// за деньги не страшно (если это число), а вот тяжёлое пальто скопируется
```

Если аргумент нужно передать по ссылке, то надо обернуть его в `ref`, а если по константной ссылке — в `cref`:
```c++
#include <functional>

// ...
future<CleaningReport> coat_future = async(CleanCoat, ref(coat), money);
// деньги копируются, пальто передаётся по неконстантной ссылке
```